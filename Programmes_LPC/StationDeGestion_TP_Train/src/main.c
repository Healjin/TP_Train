/**
 *@file main.c
 *@author Da Silva Andrade David, Antoine Berger, Dos Santos Rafael
 *@version 1.0
 *@date 19 June 2014
 *@brief This function is used to control the station with a touchscreen.
 *@brief You can select which train you want to control and it will display
 *@brief an image on the screen that correspond with the train controlled.
 *@brief To change the train select you need to use the rotation button.
 *@brief To change the speed you just press on the touchscreen the button
 *@brief with the text "Vitesse" and just increment with the rotate button.
 *@brief To turn the lights on or off, you just need to press on the button
 *@brief "LumiÃ¨re" on the touchscreen.
 */

#ifdef __USE_CMSIS
#include "LPC17xx.h"
#include "Ecran.h"
#include "police.h"
#include "SPI.h"
#include "SD.h"
#include "Touchscreen.h"
#include "uart.h"
#include "button.h"
#include "stdbool.h"
#include "SendUARTFormat.h"
#include "drawScreen.h"
#endif

/* Maximum trains available */
#define MAX_TRAIN 100
#define MAX_SPEED 1000
#define INCREMENT_SPEED 50

#define OPTION_SPEED 0
#define OPTION_TRAIN_NUMBER 1
#define TIME_ANTI_REBOUND 1

#define SPI_RATE_TOUCHSCREEN 1500000

bool flag_interrupt = 0;
uint16_t lights[MAX_TRAIN];
uint16_t speed_train[MAX_TRAIN];
bool train_direction[MAX_TRAIN]; // 1 => forward, 0 => back
int n_train = 1;
bool start_or_stop = 0; // 0 => stop, 1 => start

uint8_t red[3] = { 255, 0, 0 };
uint8_t green[3] = { 0, 255, 0 };
uint8_t blue[3] = { 0, 0, 255 };
uint8_t yellow[3] = { 255, 255, 0 };
uint8_t color_button[3] = { 229, 208, 64 };
uint8_t black[3] = { 0, 0, 0 };

uint8_t option_selected = OPTION_TRAIN_NUMBER;

/**
 *@brief integer to string in the base desired
 *@param val Value to be converted to a string
 *@param base Base on which we want the conversion
 *@return A pointer to the string that contain the conversion
 */
char* itoa(int val, int base) {
	static char buf[32] = { 0 };
	int i = 30;
	for (; val && i; --i, val /= base)
		buf[i] = "0123456789abcdef"[val % base];
	return &buf[i + 1];
}
/**
 *@brief string to integer
 *@param str String to be converted to a integer
 *@return The value of the string converted
 */
int atoi(char *str) {
	int res = 0; // Initialize result
	int i;
	// Iterate through all characters of input string and update result
	for (i = 0; str[i] != '\0'; ++i)
		res = res * 10 + str[i] - '0';

	// return result.
	return res;
}

/**
 *@brief Interruption generated by pressing on the touchscreen OR the rotate button
 *@details When someone press on the screen this interruption is called,
 *@details we run a timer to ignore all rebounds. The "flag_interrupt", which
 *@details valid the pressure, is only set after the end of timer. This flag
 *@details is scrutinized in the main function.
 *@details If we press the rotate button we just need to see if the other "edge"
 *@details state to know which way we are turning.
 */
void EINT3_IRQHandler(void) {
	/* If touchscreen interrupt */
	if (LPC_GPIOINT->IO2IntStatF == (1 << 10)) {
		/* -- Clear interrupt on the touchscreen -- */
		LPC_GPIOINT->IO2IntClr |= 1 << 10;

		/* if anti-rebound is not running */
		if (!LPC_TIM0->TCR) {
			/* Interruption in the next X ms */
			LPC_TIM0->MR0 = LPC_TIM0->TC + TIME_ANTI_REBOUND * 25000;
			LPC_TIM0->TCR = 1; /* Enable timer 0 for anti-rebound */
		}
	}
	/* If rotate button turned */
	else if (LPC_GPIOINT->IO2IntStatR == (1 << 6)) {
		LPC_GPIOINT->IO2IntClr |= 1 << 6;
		if ((LPC_GPIO2->FIOPIN & (1 << 5)) == (1 << 5)) {
			switch (option_selected) {
			case OPTION_SPEED:
				if ((speed_train[n_train] + INCREMENT_SPEED) < MAX_SPEED) {
					speed_train[n_train] = speed_train[n_train] + INCREMENT_SPEED;
					send_speed(n_train, speed_train[n_train]);
				} else {
					speed_train[n_train] = MAX_SPEED;
					send_speed(n_train, MAX_SPEED);
				}
				break;
			case OPTION_TRAIN_NUMBER:
				if (n_train < (MAX_TRAIN - 1)) {
					n_train = n_train + 1;
					/* Show the train number selected */
					Write_string_with_background("  ", 172, 35, black, color_button);
					Write_string_with_background(itoa(n_train, 10), 172, 35, black, color_button);
					/* Show the speed value of the train selected */
					Write_string_with_background("0   ", 170, 280, black, color_button);
					Write_string_with_background(itoa(speed_train[n_train], 10), 170, 280, black, color_button);

					/* Erase arrow tip */
					change_zone_color(55, 70, 280, 300, color_button);
					change_zone_color(30, 40, 280, 300, color_button);
					/* Draw new arrow */
					if (train_direction[n_train] == 0)
						draw_arrow_left(30, 290, 4, 8, 35, black);
					else
						draw_arrow_right(30, 290, 4, 8, 35, black);

					/* Actualize lights states */
					if (lights[n_train] == 1)
						display_lights(yellow, 10);
					else
						display_lights(color_button, 10);

					switch (n_train) {
					case 5:
						Set_cursor(30, 82);
						Create_partial_screen(82, 231, 30, 209);
						Read_SD_multi_block(611, 769);
						break;
					case 44:
						Set_cursor(30, 82);
						Create_partial_screen(82, 231, 30, 209);
						Read_SD_multi_block(1091, 1249);
						break;
					case 14:
						Set_cursor(30, 82);
						Create_partial_screen(82, 231, 30, 209);
						Read_SD_multi_block(931, 1089);
						break;
					case 66:
						Set_cursor(30, 82);
						Create_partial_screen(82, 231, 30, 209);
						Read_SD_multi_block(771, 929);
						break;
						/* Trains without images */
					default:
						/* We just need to actuliaze if the last train had an image */
						if ((n_train - 1 == 5) || (n_train - 1 == 14) || (n_train - 1 == 44) || (n_train - 1 == 66)) {
							Set_cursor(30, 82);
							Create_partial_screen(82, 231, 30, 209);
							/* Image with a interrogation point */
							Read_SD_multi_block(451, 609);
						}
						break;
						break;
					}
				}
				break;
			}

		} else {
			switch (option_selected) {
			case OPTION_SPEED:
				if ((speed_train[n_train] - INCREMENT_SPEED) > 0) {
					speed_train[n_train] = speed_train[n_train] - INCREMENT_SPEED;
					send_speed(n_train, speed_train[n_train]);
				} else {
					speed_train[n_train] = 0;
					send_speed(n_train, 0);
				}
				break;
			case OPTION_TRAIN_NUMBER:
				if (!(n_train <= 1)) {
					n_train = n_train - 1;
					/* Show the train number selected */
					Write_string_with_background("  ", 172, 35, black, color_button);
					Write_string_with_background(itoa(n_train, 10), 172, 35, black, color_button);
					/* Show the speed value of the train selected */
					Write_string_with_background("0   ", 170, 280, black, color_button);
					Write_string_with_background(itoa(speed_train[n_train], 10), 170, 280, black, color_button);

					/* Erase tip on the arrow */
					change_zone_color(55, 70, 280, 300, color_button);
					change_zone_color(30, 40, 280, 300, color_button);
					/* Draw new arrow */
					if (train_direction[n_train] == 1)
						draw_arrow_right(30, 290, 4, 8, 35, black);
					else
						draw_arrow_left(30, 290, 4, 8, 35, black);

					if (lights[n_train] == 1)
						display_lights(yellow, 10);
					else
						display_lights(color_button, 10);

					switch (n_train) {
					/* Show images of the trains if possible */
					case 5:
						Set_cursor(30, 82);
						Create_partial_screen(82, 231, 30, 209);
						Read_SD_multi_block(611, 769);
						break;
					case 44:
						Set_cursor(30, 82);
						Create_partial_screen(82, 231, 30, 209);
						Read_SD_multi_block(1091, 1249);
						break;
					case 14:
						Set_cursor(30, 82);
						Create_partial_screen(82, 231, 30, 209);
						Read_SD_multi_block(931, 1089);
						break;
					case 66:
						Set_cursor(30, 82);
						Create_partial_screen(82, 231, 30, 209);
						Read_SD_multi_block(771, 929);
						break;
					default:
						if ((n_train + 1 == 5) || (n_train + 1 == 14) || (n_train + 1 == 44) || (n_train + 1 == 66)) {
							Set_cursor(30, 82);
							Create_partial_screen(82, 231, 30, 209);
							Read_SD_multi_block(451, 609);
						}
						break;
					}
				}
				break;
			}
		}
	}
}

/**
 *@brief Interrupt generated by a timer when we press on the touchscreen
 *@details This timer permit to ignore multiple pressures on the screen
 *@details because of rebounds.
 */
void TIMER0_IRQHandler() {
	LPC_TIM0->TCR = 0; /* Disable timer 0 */
	/* if interruption on touchscreen still usable (not a glitch) */
	if (((LPC_GPIO2->FIOPIN & (1 << 10)) == 0))
		flag_interrupt = 1;
	/* Clear interrupt flag */
	LPC_TIM0->IR = 1;
}

/**
 *@brief Main program, initialize all devices and control the touchscreen
 *@brief pressures. If speed, light or direction if changed on the screen
 *@brief the program will send a frame through the UART that is connected
 *@brief on the XBEE.
 *@brief If someone change something on the station Marklin, all datas are
 *@brief actualized on station (ExtLab2) screen.
 */
int main(void) {

	/* Wait screen to be ready */
	int var;
	for (var = 0; var < 10000000; ++var)
		;

	Init_Extlab2();
	Init_Rotate_button();
	Init_display();
	Select_display_bus();

	Set_cursor(0, 0);
	/* -- All screen selected -- */
	/* Display size = 320x240 */
	Create_partial_screen(0, LCD_HEIGHT - 1, 0, LCD_WIDTH - 1);

	/* Init UART to use on XBEE */
	uart3_init(9600);

	/* -- Init touchscreen and configuration anti-rebound -- */
	Init_SPI_master_mode(0, 0, 300000, 8);
	LPC_TIM0->MCR = 1; /* Interrupt on MR0 value */
	NVIC_EnableIRQ(TIMER0_IRQn);
	Init_touchscreen();

	init_SD();
	/* Load the interface to command the trains */
	Read_SD_multi_block(0, 449);

	/* Restore frequency used with the touchscreen */
	Change_Frequency_SPI(SPI_RATE_TOUCHSCREEN);

	/* Add buttons to specifics positions */
	AddButton("START_STOP", 30, 90, 10, 70);
	AddButton("TRAIN_NUMBER", 150, 210, 10, 70);
	AddButton("DIRECTION", 20, 80, 250, 310);
	AddButton("LIGHTS", 90, 150, 250, 310);
	AddButton("SPEED", 160, 220, 250, 310);

	/* Show the train number selected */
	Write_string_with_background("  ", 172, 35, black, color_button);
	Write_string_with_background(itoa(n_train, 10), 172, 35, black, color_button);

	/* Show the speed value of the train selected */
	Write_string_with_background("0   ", 170, 280, black, color_button);
	Write_string_with_background(itoa(speed_train[n_train], 10), 170, 280, black, color_button);

	/* Show the start button */
	change_zone_color(35, 84, 15, 64, green);
	Write_string_with_background("START", 40, 29, black, green);

	/* Stop all trains */
	uart3_send(STOP_TRAIN, 9);

	/* Draw arrow */
	draw_arrow_right(30, 290, 4, 8, 35, black);

	/* Initialization all trains informations */
	for (var = 0; var < MAX_TRAIN; var++) {
		train_direction[var] = 1;
		speed_train[var] = 0;
		lights[var] = 1;
		send_direction(var, 1);
		send_lights(var, 1);
	}

	/* Set lights on */
	display_lights(yellow, 10);

	/* Char read on uart */
	char ch;
	/* String constructed from UART */
	char data_read[11];
	/* If a frame is ready to be read */
	bool trame_ready = false;
	/* The length of the */
	int len = 0;

	while (1) {
		/* If touchscreen pressed */
		if ((flag_interrupt == 1) && ((LPC_GPIO2->FIOPIN & (1 << 10)) == 0)) {
			uint16_t x = 0;
			uint16_t y = 0;

			/* read positions on touchscreen */
			Read_x_and_y_12bits(&x, &y);

			/* Except a bug of read SPI on touchscreen */
			if ((x == 0) || (y == 4095)) {
				flag_interrupt = 0;
				continue;
			}

			/* Convert values read in function of the screen size */
			uint32_t x_pixel = (LCD_WIDTH * (uint32_t) x) / 4096;
			uint32_t y_pixel = LCD_HEIGHT - (LCD_HEIGHT * (uint32_t) y) / 4096;

			/* Test if a button is where we pressed on the screen */
			char * button_name = IsClickOnAButton(x_pixel, y_pixel);

			if (button_name != 0) {
				if (!strcmp(button_name, "START_STOP")) {
					if (start_or_stop) {
						uart3_send(STOP_TRAIN, 9); // Send data on uart
					} else {
						uart3_send(START_TRAIN, 9); // Send data on uart
					}
					start_or_stop = !start_or_stop;
				} else if (!strcmp(button_name, "TRAIN_NUMBER")) {
					option_selected = OPTION_TRAIN_NUMBER;
				} else if (!strcmp(button_name, "DIRECTION")) {
					send_direction(n_train, !train_direction[n_train]);
					/* When we switch the direction the train will stop */
					send_speed(n_train, 0);
					speed_train[n_train] = 0;
					/* Show the speed value of the train selected */
					Write_string_with_background("0   ", 170, 280, black, color_button);
					Write_string_with_background(0, 170, 280, black, color_button);
				} else if (!strcmp(button_name, "SPEED")) {
					option_selected = OPTION_SPEED;
				} else if (!strcmp(button_name, "LIGHTS")) {
					send_lights(n_train, !lights[n_train]);
				}
			}
			flag_interrupt = 0;
		}
		/* Test UART */
		if (uart3_read_one_char(&ch)) {
			data_read[len++] = ch;
			if (ch == 0)
				trame_ready = true;
		}

		if (trame_ready) {
			switch (len) {
			case 6:
				/* Change direction on the specified train
				 *  LxxSx ==> L = line number, S = direction   */
				if (data_read[0] == 'L' && data_read[3] == 'S') {
					char tmp_char[4];

					tmp_char[0] = data_read[1];
					tmp_char[1] = data_read[2];
					tmp_char[2] = 0;
					int tmp_train = atoi(tmp_char);

					if (data_read[4] == '1') {
						//ChangeDirection(&str,n_train,FORWARD_TRAIN);
						train_direction[tmp_train] = data_read[4] - '0';
						if (tmp_train == n_train) {
							change_zone_color(55, 70, 280, 300, color_button);
							change_zone_color(30, 40, 280, 300, color_button);
							draw_arrow_right(30, 290, 4, 8, 35, black);
						}
					} else if (data_read[4] == '0') {
						//ChangeDirection(&str,n_train,BACK_TRAIN);
						train_direction[tmp_train] = data_read[4] - '0';
						if (tmp_train == n_train) {
							change_zone_color(55, 70, 280, 300, color_button);
							change_zone_color(30, 40, 280, 300, color_button);
							draw_arrow_left(30, 290, 4, 8, 35, black);
						}
					}
				} else if (data_read[0] == 'L' && data_read[3] == 'L') {
					char tmp_char[4];

					tmp_char[0] = data_read[1];
					tmp_char[1] = data_read[2];
					tmp_char[2] = 0;
					int tmp_train = atoi(tmp_char);

					lights[tmp_train] = (data_read[4] - '0');

					if (tmp_train == n_train) {
						if (lights[n_train] == 1)
							display_lights(yellow, 10);
						else
							display_lights(color_button, 10);
					}
				}
				break;
			case 9:
				/* Power ON the circuit */
				if (!strcmp(data_read, "STATRAIN")) {
					start_or_stop = true;
					change_zone_color(35, 84, 15, 64, red);
					Write_string_with_background("STOP", 45, 29, black, red);
				}
				/* Power off the circuit */
				else if (!strcmp(data_read, "STOTRAIN")) {
					start_or_stop = false;
					change_zone_color(35, 84, 15, 64, green);
					Write_string_with_background("START", 40, 29, black, green);
				}
				/* Change speed on the specified train
				 *  LxxVxxxx ==> L = line number, V = speed   */
				else if (data_read[0] == 'L' && data_read[3] == 'V') {
					char tmp_char[4];

					tmp_char[0] = data_read[1];
					tmp_char[1] = data_read[2];
					tmp_char[2] = 0;
					int tmp_train = atoi(tmp_char);

					tmp_char[0] = data_read[4];
					tmp_char[1] = data_read[5];
					tmp_char[2] = data_read[6];
					tmp_char[3] = data_read[7];
					tmp_char[4] = 0;

					speed_train[tmp_train] = atoi(tmp_char);
					if (tmp_train == n_train) {
						/* Show the speed value of the train selected */
						Write_string_with_background("0   ", 170, 280, black, color_button);
						Write_string_with_background(itoa(speed_train[n_train], 10), 170, 280, black, color_button);
					}
				}
				break;
			}
			trame_ready = false;
			len = 0;
		}
	}
	return 0;
}
